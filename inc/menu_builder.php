<?php

class menu_builder {

	private $current_item;
	private $menu_items;
	private $menu;
	private $post_id;
	
	/**
	 *	Construct the object by supplying required parameters.
	*/
	public function __construct($params) {
		
		$this->set_post_id( $params['post_id'] );
		$this->set_menu_items( $params['menu_items'] );
		$this->set_current_item( $params['post_id']);
		
	}
	
	/**
	 *	Sets the post_id variable
	*/
	public function set_post_id($post_id) {
	
		$this->post_id = $post_id;
	}
	
	/**
	 *	Sets the item data that will be used to build the menu.
	*/
	public function set_menu_items($menu_items) {
	
		$this->menu_items = $menu_items;
	}
	
	/**
	 *	Uses the supplied object id to set the current menu item.
	*/
	public function set_current_item($object_id) {
	
		foreach ($this->menu_items as $item) {
			if ($item->object_id == $object_id && $item->post_title == "") {
				$this->current_item = $item;
				return;
			}
			if ($item->object_id == $object_id) {
				$this->current_item = $item;
				return;
			}
		}
	}
	
	/**
	 *  Determine if current item has an associated menu to build.
	*/
	
	public function has_menu() {
	
		$post_id = $this->post_id;
		$in_menu = false;
		
		foreach ($this->menu_items as $item) {
		
			if ($item->object_id == $post_id) {
				if ($item->menu_item_parent != 0) {
					return true;
				}
				else {
					$in_menu = true;
					$menu_id = $item->ID;
				}
			}
		}
		
		if ($in_menu) {
			foreach ($this->menu_items as $item) {
				if ($item->menu_item_parent == $menu_id) {
					return true;
				}
			}
		}
		
		return false;
	}
	
	/**
	 *	Invokes the menu building algorithm.
	*/
	public function build() {
	
		$this->menu = $this->process_menu($this->current_item);
		return $this->menu;
	}
	
	/**
	 *	Recursively builds a hierarchical menu from the inside-out,
	 *	starting with the current item, and working towards the root parent.
	 *
	 *
	 *	The finished menu will show the following:
	 
	 *	  a) All immediate children of the current menu item ($current_item)
	 *
	 *	  b) All immediate children of the current item's parent, grandparent,
	 *	     great-grandparent, and so on, until we eventually reach the root parent.
	 *
	 *
	 *	Here are the steps involved in the algorithm:
	 *
	 *	  1) Create the current menu. This is an array with distinct keys for its elements.
	 *
	 *	  2) If a child menu was passed into the function call, merge it into the current menu.
	 *	     This is how the nested menu structures are created.
	 *
	 *	  3) If the current menu item has a parent, recurse another level deeper ("outward").
	 *	     Each parent menu wraps its child menu, until eventually we arrive at the root parent.
	 *
	 *	  4) At the root parent level, the final menu is returned back to its invoking function,
	 *	     eventually being passed back out to the original (external) invoking function.
	 *
	*/
	private function process_menu($item, $child_menu = null) {
	
		$menu['self'] = $item;
		$children = $this->get_immediate_children($item);
		
		if (count($children)) {
		
			$menu['children'] = $children;
		}
		
		if ($child_menu) {
		
			$menu = $this->merge_child_menu($menu, $child_menu);
		}
		
		if (isset($item->menu_item_parent)) {
			if ($item->menu_item_parent != 0) {
			
				$parent_item = $this->get_parent($item);
				$menu = $this->process_menu($parent_item, $menu);
			}
		}
		
		return $menu;
	}
	
	/**
	 *	Get all the immediate children (not nested children) for the supplied parent item.
	*/
	private function get_immediate_children($parent_item) {
	
		$children = array();

		foreach ($this->menu_items as $item) {
		
			if (isset($item->menu_item_parent) && isset($parent_item->ID)) {
		
				if ($item->menu_item_parent == $parent_item->ID) {
				
					$children[] = array('self' => $item);
				}
				
			}
		}
		
		return $children;
	}
	
	/**
	 *	Get the parent item for the supplied item.
	*/
	private function get_parent($item) {
	
		foreach ($this->menu_items as $parent_item) {
		
			if ($parent_item->ID == $item->menu_item_parent) {
			
				return $parent_item;
			}
		}
	}
	
	/**
	 *	Merge a child menu into a parent menu by matching the child to one of
	 *	the parent's children. This creates and returns a nested menu structure.
	*/
	private function merge_child_menu($menu, $child_menu) {
	
		foreach ($menu['children'] as &$child) {
		
			if ($child['self']->ID == $child_menu['self']->ID) {
			
				$child = $child_menu;
				return $menu;
			}
		}
	}
	
	public function to_html($menu = null, $level = 1, $html = null) {
	
		/* Did we pass in a menu? If not, we'll use the menu generated by build() as our default */
		if (!$menu) {
		
			$menu = $this->menu;
		}
		
		/* This is the item object at our current level within the menu */
		$item = $menu['self'];
		
		/* Here are the different conditions that affect our class names */
		$is_parent = isset($menu['children']);
		$is_active = $item->object_id == $this->current_item->object_id;
		$is_child = $item->menu_item_parent != 0;
		
		/* Do some stuff with the above item object and conditions to build an html snippet */
		
		
		if (($is_parent)&&($level==1)) {
		
			$html .= '<ul class="subnav"><li class="root-parent';
		}
    	elseif ($is_parent) {
    	
    		$html .= '<li class="parent';
    		
    		if ($is_child)
    			$html .= ' level-' . $level;
    		
    	}
    	elseif ($is_child) {
    	
    		$html .= '<li class="child level-' . $level;
    	}
    	else {
    		return false;
    	}
    	
    	if ($is_active) {
    	
	    		 $html .= ' active"><a href="' . $item->url . '">' . $item->title . '</a></li>';
	    }
	    else {
	    
	    		 $html .= '"><a href="' . $item->url . '">' . $item->title . '</a></li>';
	    }
    	

		
		/* If the item we're looking at is a parent, deal with its children */
		if ($is_parent && is_array($menu['children'])) {
		
			$html .='<li class="children level-' . $level . '"><ul class="children level-' . $level . '">';
			
			foreach ($menu['children'] as $child) {
			
				//recursion
				//Handle the children in the same way we handle the parents... by calling to_html()
				
				$html .= $this->to_html($child, $level+1);
			}
			$html .='</ul></li>';
		}			
		
		return $html;
	}
}